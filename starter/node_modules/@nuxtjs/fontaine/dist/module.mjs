import { pathToFileURL } from 'node:url';
import { isAbsolute } from 'node:path';
import { defineNuxtModule, useLogger, addVitePlugin, addWebpackPlugin, addPluginTemplate, addTemplate, resolveAlias } from '@nuxt/kit';
import { join } from 'pathe';
import { hasProtocol } from 'ufo';
import MagicString from 'magic-string';
import { getMetricsForFamily, readMetrics, generateFontFace, generateFallbackName, FontaineTransform } from 'fontaine';

const NitroTransformPlugin = (options) => ({
  name: "nuxt-fontaine-transform-nitro",
  transform(code, source) {
    if (!code.includes("__INLINED_CSS__"))
      return;
    const s = new MagicString(code);
    s.replace("__INLINED_CSS__", `\` ${options.cssContext.value.replace(/\s+/g, " ")}\``);
    return {
      code: s.toString(),
      map: options.sourcemap ? s.generateMap({ source, includeContent: true }) : void 0
    };
  }
});

const module = defineNuxtModule({
  meta: {
    configKey: "fontMetrics",
    name: "@nuxtjs/fontaine",
    compatibility: {
      nuxt: "^3.0.0-rc.6"
    }
  },
  defaults: (nuxt) => ({
    inject: true,
    inline: nuxt.options.ssr,
    fallbacks: ["BlinkMacSystemFont", "Segoe UI", "Roboto", "Helvetica Neue", "Arial", "Noto Sans"],
    fonts: []
  }),
  async setup(options, nuxt) {
    if (nuxt.options._prepare)
      return;
    if (nuxt.options.fontMetrics?.fallbacks) {
      options.fallbacks = nuxt.options.fontMetrics?.fallbacks;
    }
    const logger = useLogger("@nuxtjs/fontaine");
    const css = (async () => {
      let css2 = "";
      for (const font of options.fonts) {
        const {
          family,
          src,
          fallbackName,
          fallbacks,
          root: fontRoot
        } = typeof font === "string" ? { family: font } : font;
        let metrics = await getMetricsForFamily(family);
        if (!metrics && src && !hasProtocol(src)) {
          const file = join(
            nuxt.options.srcDir,
            fontRoot ?? options.root ?? nuxt.options.dir.public,
            src
          );
          metrics = await readMetrics(pathToFileURL(file));
        }
        if (!metrics) {
          logger.warn("Could not find metrics for font", family);
          continue;
        }
        for (const font2 of fallbacks || options.fallbacks) {
          css2 += generateFontFace(metrics, {
            name: fallbackName || generateFallbackName(family),
            font: font2,
            metrics: await getMetricsForFamily(font2)
          });
        }
      }
      return css2;
    })();
    const cssContext = { value: "" };
    if (options.inject) {
      const resolvePath = (id) => {
        if (hasProtocol(id))
          return id;
        if (isAbsolute(id))
          return pathToFileURL(join(nuxt.options.srcDir, nuxt.options.dir.public, id));
        return pathToFileURL(resolveAlias(id));
      };
      const transformOptions = {
        fallbacks: options.fallbacks,
        resolvePath,
        css: cssContext,
        skipFontFaceGeneration: (fallbackName) => {
          return options.inline && options.fonts.some((font) => {
            const previouslyGeneratedFallbackName = typeof font === "string" ? generateFallbackName(font) : font.fallbackName || generateFallbackName(font.family);
            return previouslyGeneratedFallbackName === fallbackName;
          });
        },
        sourcemap: nuxt.options.sourcemap.client
      };
      addVitePlugin(FontaineTransform.vite(transformOptions), { server: false });
      addWebpackPlugin(FontaineTransform.webpack(transformOptions), { server: false });
      nuxt.hook("nitro:config", async (config) => {
        const plugins = await config.rollupConfig.plugins;
        if (!plugins || !Array.isArray(plugins))
          return;
        plugins.push(
          NitroTransformPlugin({
            sourcemap: true,
            cssContext
          })
        );
      });
    }
    if (options.inline) {
      addPluginTemplate({
        filename: "font-fallback-inlining-plugin.server.ts",
        getContents: async () => [
          `import { defineNuxtPlugin, useHead } from '#imports'`,
          `const css = \`${(await css).replace(/\s+/g, " ")}\``,
          `export default defineNuxtPlugin(() => { useHead({ style: [{ children: css ${!nuxt.options.dev && options.inject ? "+ __INLINED_CSS__ " : ""}}] }) })`
        ].join("\n"),
        mode: "server"
      });
    } else {
      addTemplate({
        filename: "font-fallbacks.css",
        write: true,
        getContents: () => css
      });
      nuxt.options.css.push("#build/font-fallbacks.css");
    }
  }
});

export { module as default };
