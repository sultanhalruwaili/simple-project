'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('cross-fetch/polyfill');
var blobToBuffer = require('blob-to-buffer');
var fontkit = require('fontkit');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var blobToBuffer__default = /*#__PURE__*/_interopDefault(blobToBuffer);
var fontkit__default = /*#__PURE__*/_interopDefault(fontkit);

// Ref: https://en.wikipedia.org/wiki/Letter_frequency#Relative_frequencies_of_letters_in_other_languages
const weightings = {
  a: 0.0668,
  b: 0.0122,
  c: 0.0228,
  d: 0.0348,
  e: 0.1039,
  f: 0.0182,
  g: 0.0165,
  h: 0.0499,
  i: 0.057,
  j: 0.0013,
  k: 0.0063,
  l: 0.0329,
  m: 0.0197,
  n: 0.0552,
  o: 0.0614,
  p: 0.0158,
  q: 0.0008,
  r: 0.049,
  s: 0.0518,
  t: 0.0741,
  u: 0.0226,
  v: 0.008,
  w: 0.0193,
  x: 0.0012,
  y: 0.0162,
  z: 0.0006,
  ' ': 0.1818
};
const sampleString = Object.keys(weightings).join('');
const weightingForCharacter = character => {
  if (!Object.keys(weightings).includes(character)) {
    throw new Error("No weighting specified for character: \u201C".concat(character, "\u201D"));
  }
  return weightings[character];
};
const unpackMetricsFromFont = font => {
  const {
    capHeight,
    ascent,
    descent,
    lineGap,
    unitsPerEm,
    familyName,
    xHeight
  } = font;
  const glyphs = font.glyphsForString(sampleString);
  const weightedWidth = glyphs.reduce((sum, glyph, index) => {
    const character = sampleString.charAt(index);
    let charWidth = font['OS/2'].xAvgCharWidth;
    try {
      charWidth = glyph.advanceWidth;
    } catch (e) {
      console.warn("Couldn\u2019t read 'advanceWidth' for character \u201C".concat(character === ' ' ? '<space>' : character, "\u201D from \u201C").concat(familyName, "\u201D. Falling back to \u201CxAvgCharWidth\u201D."));
    }
    return sum + charWidth * weightingForCharacter(character);
  }, 0);
  return {
    familyName,
    capHeight,
    ascent,
    descent,
    lineGap,
    unitsPerEm,
    xHeight,
    xWidthAvg: Math.round(weightedWidth)
  };
};
const fromFile = path => fontkit__default["default"].open(path).then(unpackMetricsFromFont);
const fromBlob = async blob => new Promise((resolve, reject) => {
  blobToBuffer__default["default"](blob, (err, buffer) => {
    if (err) {
      return reject(err);
    }
    try {
      resolve(unpackMetricsFromFont(fontkit__default["default"].create(buffer)));
    } catch (e) {
      reject(e);
    }
  });
});
const fromUrl = async url => {
  const response = await fetch(url);
  if (typeof window === 'undefined') {
    const data = await response.arrayBuffer();
    return unpackMetricsFromFont(fontkit__default["default"].create(Buffer.from(data)));
  }
  const blob = await response.blob();
  return fromBlob(blob);
};

exports.fromBlob = fromBlob;
exports.fromFile = fromFile;
exports.fromUrl = fromUrl;
